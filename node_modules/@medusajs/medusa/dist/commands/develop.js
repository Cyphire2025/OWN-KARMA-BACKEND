"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = default_1;
const framework_1 = require("@medusajs/framework");
const utils_1 = require("@medusajs/framework/utils");
const telemetry_1 = require("@medusajs/telemetry");
const boxen_1 = __importDefault(require("boxen"));
const child_process_1 = require("child_process");
const chokidar_1 = __importDefault(require("chokidar"));
const os_1 = require("os");
const path_1 = __importDefault(require("path"));
const backend_hmr_1 = __importDefault(require("../feature-flags/backend-hmr"));
const loaders_1 = require("../loaders");
const defaultConfig = {
    padding: 5,
    borderColor: `blue`,
    borderStyle: `double`,
};
async function default_1({ types, directory }) {
    const container = await (0, loaders_1.initializeContainer)(directory);
    const logger = container.resolve(utils_1.ContainerRegistrationKeys.LOGGER);
    const isBackendHmrEnabled = utils_1.FeatureFlag.isFeatureEnabled(backend_hmr_1.default.key);
    const reloadActionVerb = isBackendHmrEnabled ? "reloading" : "restarting";
    const logSource = isBackendHmrEnabled ? "[HMR]" : "[Watcher]";
    if (isBackendHmrEnabled) {
        logger.info(`${logSource} Using backend HMR dev server (reload on file change)`);
    }
    else {
        logger.info(`${logSource} Using standard dev server (restart on file change)`);
    }
    const args = process.argv;
    const argv = process.argv.indexOf("--") !== -1
        ? process.argv.slice(process.argv.indexOf("--") + 1)
        : [];
    args.shift();
    args.shift();
    args.shift();
    if (types) {
        args.push("--types");
    }
    /**
     * Re-constructing the path to Medusa CLI to execute the
     * start command.
     */
    const cliPath = path_1.default.resolve(framework_1.MEDUSA_CLI_PATH, "..", "..", "cli.js");
    const devServer = {
        childProcess: null,
        watcher: null,
        /**
         * Start the development server by forking a new process.
         *
         * We do not kill the parent process when child process dies. This is
         * because sometimes the dev server can die because of programming
         * or logical errors and we can still watch the file system and
         * restart the dev server instead of asking the user to re-run
         * the command.
         */
        async start() {
            const forkOptions = {
                cwd: directory,
                env: {
                    ...process.env,
                    NODE_ENV: "development",
                    ...(isBackendHmrEnabled && { MEDUSA_HMR_ENABLED: "true" }),
                },
                execArgv: argv,
            };
            // Enable IPC for HMR mode to communicate reload requests
            if (isBackendHmrEnabled) {
                forkOptions.stdio = ["inherit", "inherit", "inherit", "ipc"];
            }
            this.childProcess = (0, child_process_1.fork)(cliPath, ["start", ...args], forkOptions);
            this.childProcess.on("error", (error) => {
                // @ts-ignore
                logger.error(`${logSource} Dev server failed to start`, error);
                logger.info(`${logSource} The server will restart automatically after your changes`);
            });
        },
        /**
         * Sends an HMR reload request to the child process and waits for result.
         * Returns true if reload succeeded, false if it failed.
         */
        async sendHmrReload(action, file) {
            return new Promise((resolve) => {
                if (!this.childProcess) {
                    resolve(false);
                    return;
                }
                const timeout = setTimeout(() => {
                    resolve(false);
                }, 30000); // 30s timeout
                const messageHandler = (msg) => {
                    if (msg?.type === "hmr-result") {
                        clearTimeout(timeout);
                        this.childProcess?.off("message", messageHandler);
                        resolve(msg.success === true);
                    }
                };
                this.childProcess.on("message", messageHandler);
                this.childProcess.send({
                    type: "hmr-reload",
                    action,
                    file: path_1.default.resolve(directory, file),
                    rootDirectory: directory,
                });
            });
        },
        /**
         * Restarts the development server by cleaning up the existing
         * child process and forking a new one
         */
        async restart(action, file) {
            if (isBackendHmrEnabled && this.childProcess) {
                const success = await this.sendHmrReload(action, file);
                if (success) {
                    return;
                }
                // HMR reload failed, kill the process and restart
                logger.info(`${logSource} HMR reload failed, restarting server...`);
            }
            if (this.childProcess) {
                this.childProcess.removeAllListeners();
                if (process.platform === "win32") {
                    (0, child_process_1.execSync)(`taskkill /PID ${this.childProcess.pid} /F /T`);
                }
                else {
                    this.childProcess.kill("SIGINT");
                }
            }
            await this.start();
        },
        /**
         * Watches the entire file system and ignores the following files
         *
         * - Dot files
         * - node_modules
         * - dist
         * - src/admin/**
         */
        watch() {
            this.watcher = chokidar_1.default.watch(".", {
                ignoreInitial: true,
                cwd: directory,
                ignored: [
                    /(^|[\\/\\])\../,
                    "node_modules",
                    "dist",
                    "static",
                    "private",
                    "src/admin",
                    ".medusa",
                ],
            });
            async function handleFileChange(action, file) {
                const actionVerb = action === "add"
                    ? "created"
                    : action === "change"
                        ? "modified"
                        : "removed";
                const now = performance.now();
                logger.info(`${logSource} ${actionVerb} ${path_1.default.relative(directory, file)} ${actionVerb}: ${reloadActionVerb} dev server`);
                await this.restart(action, file);
                const duration = performance.now() - now;
                logger.info(`${logSource} Reloaded in ${duration.toFixed(2)}ms`);
            }
            this.watcher.on("add", async (file) => {
                handleFileChange.call(this, "add", file);
            });
            this.watcher.on("change", async (file) => {
                handleFileChange.call(this, "change", file);
            });
            this.watcher.on("unlink", async (file) => {
                handleFileChange.call(this, "unlink", file);
            });
            this.watcher.on("ready", function () {
                logger.info(`${logSource} Watching filesystem to reload dev server on file change`);
            });
        },
    };
    process.on("SIGINT", () => {
        const configStore = new telemetry_1.Store();
        const hasPrompted = configStore.getConfig("star.prompted") ?? false;
        if (!hasPrompted) {
            const defaultMessage = `✨ Thanks for using Medusa. ✨${os_1.EOL}${os_1.EOL}` +
                `If you liked it, please consider starring us on GitHub${os_1.EOL}` +
                `https://medusajs.com/star${os_1.EOL}` +
                `${os_1.EOL}` +
                `Note: you will not see this message again.`;
            console.log();
            console.log((0, boxen_1.default)(defaultMessage, defaultConfig));
            configStore.setConfig("star.prompted", true);
        }
        process.exit(0);
    });
    await devServer.start();
    devServer.watch();
}
//# sourceMappingURL=develop.js.map