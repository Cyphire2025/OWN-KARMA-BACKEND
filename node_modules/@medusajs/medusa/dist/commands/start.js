"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.traceRequestHandler = void 0;
exports.registerInstrumentation = registerInstrumentation;
const telemetry_1 = require("@medusajs/telemetry");
const cluster_1 = __importDefault(require("cluster"));
const express_1 = __importDefault(require("express"));
const http_1 = __importDefault(require("http"));
const node_schedule_1 = require("node-schedule");
const os_1 = __importDefault(require("os"));
const path_1 = __importDefault(require("path"));
const utils_1 = require("@medusajs/framework/utils");
const modules_sdk_1 = require("@medusajs/framework/modules-sdk");
const url_1 = require("url");
const rbac_1 = __importDefault(require("../feature-flags/rbac"));
const loaders_1 = __importStar(require("../loaders"));
const dev_server_1 = require("./utils/dev-server");
const errors_1 = require("./utils/dev-server/errors");
const EVERY_SIXTH_HOUR = "0 */6 * * *";
const CRON_SCHEDULE = EVERY_SIXTH_HOUR;
const INSTRUMENTATION_FILE = "instrumentation";
function parseValueOrPercentage(value, base) {
    if (typeof value !== "string") {
        throw new Error(`Invalid value: ${value}. Must be a string.`);
    }
    const trimmed = value.trim();
    if (trimmed.endsWith("%")) {
        const percent = parseFloat(trimmed.slice(0, -1));
        if (isNaN(percent)) {
            throw new Error(`Invalid percentage: ${value}`);
        }
        if (percent < 0 || percent > 100) {
            throw new Error(`Percentage must be between 0 and 100: ${value}`);
        }
        return Math.round((percent / 100) * base);
    }
    else {
        const num = parseInt(trimmed, 10);
        if (isNaN(num) || num < 0) {
            throw new Error(`Invalid number: ${value}. Must be a non-negative integer.`);
        }
        return num;
    }
}
/**
 * Imports the "instrumentation.js" file from the root of the
 * directory and invokes the register function. The existence
 * of this file is optional, hence we ignore "ENOENT"
 * errors.
 */
async function registerInstrumentation(directory) {
    const container = await (0, loaders_1.initializeContainer)(directory, {
        skipDbConnection: true,
    });
    const logger = container.resolve(utils_1.ContainerRegistrationKeys.LOGGER);
    const fileSystem = new utils_1.FileSystem(directory);
    const exists = (await fileSystem.exists(`${INSTRUMENTATION_FILE}.ts`)) ||
        (await fileSystem.exists(`${INSTRUMENTATION_FILE}.js`));
    if (!exists) {
        return;
    }
    const instrumentation = await (0, utils_1.dynamicImport)(path_1.default.join(directory, INSTRUMENTATION_FILE));
    if (typeof instrumentation.register === "function" &&
        !(0, utils_1.isFileSkipped)(instrumentation)) {
        logger.info("OTEL registered");
        instrumentation.register();
    }
    else {
        logger.info("Skipping instrumentation registration. No register function found.");
    }
}
/**
 * Wrap request handler inside custom implementation to enabled
 * instrumentation.
 */
// eslint-disable-next-line no-var
exports.traceRequestHandler = void 0;
function displayAdminUrl({ host, port, container, }) {
    const isProduction = ["production", "prod"].includes(process.env.NODE_ENV || "");
    if (isProduction) {
        return;
    }
    const logger = container.resolve(utils_1.ContainerRegistrationKeys.LOGGER);
    const { admin: { path: adminPath, disable }, } = container.resolve(utils_1.ContainerRegistrationKeys.CONFIG_MODULE);
    if (disable) {
        return;
    }
    logger.info(`Admin URL â†’ http://${host || "localhost"}:${port}${adminPath}`);
}
/**
 * Retrieve the route path from the express stack based on the input url
 * @param stack - The express stack
 * @param url - The input url
 * @returns The route path
 */
function findExpressRoutePath({ stack, url, }) {
    const stackToProcess = [...stack];
    while (stackToProcess.length > 0) {
        const layer = stackToProcess.pop();
        if (layer.name === "bound dispatch" && layer.match(url)) {
            return layer.route.path;
        }
        // Add nested stack items to be processed if they exist
        if (layer.handle?.stack?.length) {
            stackToProcess.push(...layer.handle.stack);
        }
    }
    return undefined;
}
function handleHMRReload(logger) {
    // Set up HMR reload handler if running in HMR mode
    if (process.env.MEDUSA_HMR_ENABLED === "true" && process.send) {
        ;
        global.__MEDUSA_HMR_ROUTE_REGISTRY__ = true;
        process.on("message", async (msg) => {
            if (msg?.type === "hmr-reload") {
                const { action, file, rootDirectory } = msg;
                const success = await (0, dev_server_1.reloadResources)({
                    logSource: "[HMR]",
                    action,
                    absoluteFilePath: file,
                    logger,
                    rootDirectory,
                })
                    .then(() => true)
                    .catch((error) => {
                    if (errors_1.HMRReloadError.isHMRReloadError(error)) {
                        return false;
                    }
                    logger.error("[HMR] Reload failed with unexpected error", error);
                    return false;
                });
                process.send({ type: "hmr-result", success });
            }
        });
    }
}
async function start(args) {
    const { port = 9000, host, directory, types, cluster: clusterSize, workers, servers, } = args;
    const maxCpus = os_1.default.cpus().length;
    const clusterSizeNum = clusterSize
        ? parseValueOrPercentage(clusterSize, maxCpus)
        : maxCpus;
    const serversCount = servers
        ? parseValueOrPercentage(servers, clusterSizeNum)
        : 0;
    const workersCount = workers
        ? parseValueOrPercentage(workers, clusterSizeNum)
        : 0;
    async function internalStart(generateTypes) {
        (0, telemetry_1.track)("CLI_START");
        const container = await (0, loaders_1.initializeContainer)(directory, {
            skipDbConnection: true,
        });
        const logger = container.resolve(utils_1.ContainerRegistrationKeys.LOGGER);
        const serverActivity = logger.activity(`Creating server`);
        await registerInstrumentation(directory);
        const app = (0, express_1.default)();
        const http_ = http_1.default.createServer(async (req, res) => {
            const stack = app._router.stack;
            await new Promise((resolve) => {
                res.on("finish", resolve);
                if (exports.traceRequestHandler) {
                    const expressHandlerPath = findExpressRoutePath({
                        stack,
                        url: (0, url_1.parse)(req.url, false).pathname,
                    });
                    void (0, exports.traceRequestHandler)(async () => {
                        app(req, res);
                    }, req, res, expressHandlerPath);
                }
                else {
                    app(req, res);
                }
            });
        });
        try {
            const { shutdown, gqlSchema, container, modules } = await (0, loaders_1.default)({
                directory,
                expressApp: app,
            });
            if (generateTypes) {
                const typesDirectory = path_1.default.join(directory, ".medusa/types");
                const fileGenPromises = [];
                fileGenPromises.push((0, utils_1.generateContainerTypes)(modules, {
                    outputDir: typesDirectory,
                    interfaceName: "ModuleImplementations",
                }));
                if (gqlSchema) {
                    fileGenPromises.push((0, utils_1.gqlSchemaToTypes)({
                        outputDir: typesDirectory,
                        filename: "query-entry-points",
                        interfaceName: "RemoteQueryEntryPoints",
                        schema: gqlSchema,
                        joinerConfigs: modules_sdk_1.MedusaModule.getAllJoinerConfigs(),
                    }));
                }
                if (utils_1.FeatureFlag.isFeatureEnabled(rbac_1.default.key)) {
                    fileGenPromises.push((0, utils_1.generatePolicyTypes)({
                        outputDir: typesDirectory,
                    }));
                }
                await (0, utils_1.promiseAll)(fileGenPromises);
                logger.debug("Generated policy types");
            }
            // Register a health check endpoint. Ideally this also checks the readiness of the service, rather than just returning a static response.
            app.get("/health", (_, res) => {
                res.status(200).send("OK");
            });
            const server = utils_1.GracefulShutdownServer.create(http_.listen(port, host).on("listening", () => {
                logger.success(serverActivity, `Server is ready on port: ${port}`);
                displayAdminUrl({ container, host, port });
                (0, telemetry_1.track)("CLI_START_COMPLETED");
            }));
            // Handle graceful shutdown
            const gracefulShutDown = () => {
                logger.info("Gracefully shutting down server");
                server
                    .shutdown()
                    .then(async () => {
                    await shutdown();
                    process.exit(0);
                })
                    .catch((e) => {
                    logger.error("Error received when shutting down the server.", e);
                    process.exit(1);
                });
            };
            process.on("SIGTERM", gracefulShutDown);
            process.on("SIGINT", gracefulShutDown);
            (0, node_schedule_1.scheduleJob)(CRON_SCHEDULE, () => {
                (0, telemetry_1.track)("PING");
            });
            handleHMRReload(logger);
            return { server, gracefulShutDown };
        }
        catch (err) {
            logger.error("Error starting server", err);
            process.exit(1);
        }
    }
    /**
     * When the cluster flag is used we will start the process in
     * cluster mode
     */
    if ("cluster" in args) {
        const cpus = clusterSizeNum;
        const numCPUs = Math.min(maxCpus, cpus);
        if (serversCount + workersCount > numCPUs) {
            throw new Error(`Sum of servers (${serversCount}) and workers (${workersCount}) cannot exceed cluster size (${numCPUs})`);
        }
        if (cluster_1.default.isPrimary) {
            let isShuttingDown = false;
            const killMainProccess = () => process.exit(0);
            const gracefulShutDown = () => {
                isShuttingDown = true;
            };
            for (let index = 0; index < numCPUs; index++) {
                const worker = cluster_1.default.fork();
                let workerMode = "shared";
                if (index < serversCount) {
                    workerMode = "server";
                }
                else if (index < serversCount + workersCount) {
                    workerMode = "worker";
                }
                worker.on("online", () => {
                    worker.send({ index, workerMode });
                });
            }
            cluster_1.default.on("exit", () => {
                if (!isShuttingDown) {
                    cluster_1.default.fork();
                }
                else if (!(0, utils_1.isPresent)(cluster_1.default.workers)) {
                    setTimeout(killMainProccess, 100).unref();
                }
            });
            process.on("SIGTERM", gracefulShutDown);
            process.on("SIGINT", gracefulShutDown);
        }
        else {
            process.on("message", async (msg) => {
                if (msg.workerMode) {
                    process.env.MEDUSA_WORKER_MODE = msg.workerMode;
                }
                if (msg.index > 0) {
                    process.env.PLUGIN_ADMIN_UI_SKIP_CACHE = "true";
                }
                return await internalStart(!!types && msg.index === 0);
            });
        }
    }
    else {
        /**
         * Not in cluster mode
         */
        return await internalStart(!!types);
    }
}
exports.default = start;
//# sourceMappingURL=start.js.map